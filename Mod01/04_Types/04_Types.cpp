#include <iostream>
using namespace std;

int main()
{
    double f;
    unsigned char l;
    unsigned long  r;
    int i;
    float x;
    f = 20;  cout << "sizeof(f)=" << sizeof(f) << endl;
    l = 2;   cout << "sizeof(l)=" << sizeof(l) << endl;
    r = 3;   cout << "sizeof(r)=" << sizeof(r) << endl;
    i = 4;   cout << "sizeof(i)=" << sizeof(i) << endl;
    x = f / (i + l * r);

    cout << "sizeof(l*r)=" << sizeof(l * r) << endl;
    cout << "sizeof(i+l*r)=" << sizeof(i + l * r) << endl;
    cout << "sizeof(f/(i+l*r)=" << sizeof(f / (i + r * l)) << endl;
    cout << "sizeof(x)=" << sizeof(x) << endl;
    system("Pause");

    // Проверка целочисленного деления
    int a = 5;
    float z1, z2;
    z1 = a / 2;			            //	z1 = 5/2 = 2
    z2 = (double)a / 2;	        //	z2 = 5./2 = 2.5
    auto z21 = double(a) / 2;	    //	z21 = 5./2 = 2.5
    cout << "\t z1=" << z1 << "\tsize-" << sizeof(z1) << endl;
    cout << "\t z2=" << z2 << "\tsize-" << sizeof(z2) << endl;
    cout << "\t z21=" << z21 << "\tsize-" << sizeof(z21) << endl;
    cout << "\t a=" << a << "\tsize-" << sizeof(a) << endl;
    system("Pause");

    // Проверка целочисленного unsigned 
    int k1 = -1;
    unsigned int k2 = k1;
    cout << "\t k2= " << k2 << "\tsize-" << sizeof(k2) << endl;
    /*
    C++ свободно конвертирует числа с типами unsigned в типы signed и наоборот
    без проверки диапазона допустимых значений определенного типа данных
    */
    system("Pause");

    // Проверка вещественных типов - ошибки компьютерных вычислений, 
    // вызванные применением чисел в формате IEEE754

    float af = 123456789, bf = 123456788, ff;
    ff = af - bf;                       // должно быть 1.0
    cout << "ff = " << ff << endl;      // а будет 8
    /*
    Почему ответ получился неправильным?
Число 123456789 в single=4CEB79A3hex(ieee)=123456792(dec) абсолютная ошибка представления равна +3
Число 123456788 в single=4CEB79A2hex(ieee)=123456784(dec) абсолютная ошибка представления равна -4
Относительная погрешность исходных чисел приблизительно равна 3,24e-6%
В результате одной операции относительная погрешность результата стала 800%, т.е. увеличилась в 2,5e+8 раз.
    */
    double k11 = 123456789.123457;
    float k22 = 123456789.123457;
    cout << "k22 - k11 = " << k22 - k11 << endl;
    /*
    Ошибка вызваны тем, что исходное число представленное в формате single и в формате double обычно не равны друг другу.
исходное число: 123456789,123456789
Single: 4CEB79A3=+123456792,0(dec)
Double: 419D6F34547E6B75=+123456789,12345679104328155517578125
Разница между Single и Double составит:2,87654320895671844482421875
    */

    /* Мало просто привести все исходные данные к одному типу, необходимо
    привести также результаты промежуточных операций к одному типу.*/
    float aa = 1, bb = 3;
    float cc = aa / bb;
    cc = cc - 1 / 3;
    // cc = cc - (float)1 / 3;
    // cc = cc - 1.f/ 3;
    cout << "0: " << cc << endl;

    // Пример. "Фасовка"
    float tabl = 0.00001;    // вес таблетки в кг
    float prod = 300;    // продукции в бункере в кг (300-исходный вес бункера)
    for (size_t n = 1; n < 10000000; n++)
    {
        prod = prod - tabl; //одна таблетка забирается фасовочной машино
    }
    cout << "Prod = " << prod << endl;              // 300 ?
    /*
    В данном примере фасовочная машина забрала из бункера 100 кг продукции,
    а вес продукции в бункере не изменился.
    Почему не изменился?
    Потому, что мантиссы чисел 300 и 0,00001 не пересекаются для формата single.*/
    return 0;
}
/*Более подробно о IEEE 754 - стандарте двоичной арифметики с плавающей точкой
и особенно о проблемах компьютерных вычислений, вызванные использованием этого стандарта (п.9)
см. https://www.softelectro.ru/ieee754.html */